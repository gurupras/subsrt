{"version":3,"sources":["webpack://subsrt/webpack/universalModuleDefinition","webpack://subsrt/webpack/bootstrap","webpack://subsrt/./lib/format/vtt.js","webpack://subsrt/./lib/format/lrc.js","webpack://subsrt/./lib/format/smi.js","webpack://subsrt/./lib/format/ssa.js","webpack://subsrt/./lib/format/ass.js","webpack://subsrt/./lib/format/sub.js","webpack://subsrt/./lib/format/srt.js","webpack://subsrt/./lib/format/sbv.js","webpack://subsrt/./lib/format/json.js","webpack://subsrt/./lib/subsrt.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","helper","toMilliseconds","match","exec","parseInt","replace","toTimeString","ms","hh","Math","floor","mm","ss","ff","vtt","detect","content","Error","test","parse","options","caption","index","captions","eol","parts","split","length","type","cue","start","end","duration","lines","join","text","push","meta","data","verbose","console","log","build","toString","String","lrc","prev","trim","tag","lyrics","htmlEncode","htmlDecode","html","smi","title","style","part","blank","preserveSpaces","langName","langCode","closeTags","getPosition","search","ssa","indexOf","values","columns","line","indexOfText","substr","ass","format","FORMAT_NAME","DEFAULT_FPS","sub","fps","frame","count","round","_typeof","srt","sbv","json","JSON","stringify","subsrt","clone","obj","handlers","vttHandler","lrcHandler","smiHandler","ssaHandler","assHandler","subHandler","srtHandler","sbvHandler","jsonHandler","handler","list","keys","formats","f","func","convert","to","opt","from","resync","shift","ratio","offset","a","subsrt_typeof","resynced"],"mappings":"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","file":"bundle.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"subsrt\"] = factory();\n\telse\n\t\troot[\"subsrt\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","'use strict'\n\nvar FORMAT_NAME = 'vtt'\n\nvar helper = {\n  toMilliseconds: function (s) {\n    var match = /^\\s*(\\d{1,2}:)?(\\d{1,2}):(\\d{1,2})([.,](\\d{1,3}))?\\s*$/.exec(s)\n    var hh = match[1] ? parseInt(match[1].replace(':', '')) : 0\n    var mm = parseInt(match[2])\n    var ss = parseInt(match[3])\n    var ff = match[5] ? parseInt(match[5]) : 0\n    var ms = hh * 3600 * 1000 + mm * 60 * 1000 + ss * 1000 + ff\n    return ms\n  },\n  toTimeString: function (ms) {\n    var hh = Math.floor(ms / 1000 / 3600)\n    var mm = Math.floor(ms / 1000 / 60 % 60)\n    var ss = Math.floor(ms / 1000 % 60)\n    var ff = Math.floor(ms % 1000)\n    var time = (hh < 10 ? '0' : '') + hh + ':' + (mm < 10 ? '0' : '') + mm + ':' + (ss < 10 ? '0' : '') + ss + '.' + (ff < 100 ? '0' : '') + (ff < 10 ? '0' : '') + ff\n    return time\n  }\n}\n\n/******************************************************************************************\n * Parses captions in WebVTT format (Web Video Text Tracks Format)\n ******************************************************************************************/\nfunction parse (content, options) {\n  var index = 1\n  var captions = [ ]\n  let caption\n  var eol = options.eol || '\\r\\n'\n  var parts = content.split(/\\r?\\n\\s+\\r?\\n/)\n  for (var i = 0; i < parts.length; i++) {\n    // WebVTT data\n    var regex = /^([^\\r\\n]+\\r?\\n)?((\\d{1,2}:)?\\d{1,2}:\\d{1,2}([.,]\\d{1,3})?)\\s*-->\\s*((\\d{1,2}:)?\\d{1,2}:\\d{1,2}([.,]\\d{1,3})?)\\r?\\n([\\s\\S]*)(\\r?\\n)*$/gi\n    var match = regex.exec(parts[i])\n    if (match) {\n      caption = { }\n      caption.type = 'caption'\n      caption.index = index++\n      if (match[1]) {\n        caption.cue = match[1].replace(/[\\r\\n]*/gi, '')\n      }\n      caption.start = helper.toMilliseconds(match[2])\n      caption.end = helper.toMilliseconds(match[5])\n      caption.duration = caption.end - caption.start\n      var lines = match[8].split(/\\r?\\n/)\n      caption.content = lines.join(eol)\n      caption.text = caption.content\n        .replace(/<[^>]+>/g, '') // <b>bold</b> or <i>italic</i>\n        .replace(/\\{[^}]+\\}/g, '') // {b}bold{/b} or {i}italic{/i}\n      captions.push(caption)\n      continue\n    }\n\n    // WebVTT meta\n    var meta = /^([A-Z]+)(\\r?\\n([\\s\\S]*))?$/.exec(parts[i])\n    if (!meta) {\n      // Try inline meta\n      meta = /^([A-Z]+)\\s+([^\\r\\n]*)?$/.exec(parts[i])\n    }\n    if (meta) {\n      caption = { }\n      caption.type = 'meta'\n      caption.name = meta[1]\n      if (meta[3]) {\n        caption.data = meta[3]\n      }\n      captions.push(caption)\n      continue\n    }\n\n    if (options.verbose) {\n      console.log('WARN: Unknown part', parts[i])\n    }\n  }\n  return captions\n};\n\n/******************************************************************************************\n * Builds captions in WebVTT format (Web Video Text Tracks Format)\n ******************************************************************************************/\nfunction build (captions, options) {\n  var eol = options.eol || '\\r\\n'\n  var content = 'WEBVTT' + eol + eol\n  for (var i = 0; i < captions.length; i++) {\n    var caption = captions[i]\n    if (caption.type === 'meta') {\n      if (caption.name === 'WEBVTT') continue\n      if (caption.name) {\n        content += caption.name + eol\n      }\n      if (caption.data) {\n        let data = caption.data\n        if (!(data instanceof String)) {\n          // TODO: Figure out how to convert this to WebVTT format\n          content += eol\n          continue\n        }\n        content += caption.data ? caption.data + eol : ''\n      }\n      content += eol\n      continue\n    }\n\n    if (typeof caption.type === 'undefined' || caption.type === 'caption') {\n      content += (i + 1).toString() + eol\n      content += helper.toTimeString(caption.start) + ' --> ' + helper.toTimeString(caption.end) + eol\n      content += caption.text + eol\n      content += eol\n      continue\n    }\n\n    if (options.verbose) {\n      console.log('SKIP:', caption)\n    }\n  }\n\n  return content\n};\n\n/******************************************************************************************\n * Detects a subtitle format from the content.\n ******************************************************************************************/\nfunction detect (content) {\n  if (typeof content !== 'string') {\n    throw new Error('Expected string content!')\n  }\n\n  if (/^[\\s\\r\\n]*WEBVTT\\r?\\n/g.test(content)) {\n    /*\n    WEBVTT\n    ...\n    */\n    return 'vtt'\n  }\n};\n\n/******************************************************************************************\n * Export\n ******************************************************************************************/\nexport default {\n  name: FORMAT_NAME,\n  helper: helper,\n  detect: detect,\n  parse: parse,\n  build: build\n}\n","'use strict'\n\nvar FORMAT_NAME = 'lrc'\n\nvar helper = {\n  toMilliseconds: function (s) {\n    var match = /^\\s*(\\d+):(\\d{1,2})([.,](\\d{1,3}))?\\s*$/.exec(s)\n    var mm = parseInt(match[1])\n    var ss = parseInt(match[2])\n    var ff = match[4] ? parseInt(match[4]) : 0\n    var ms = mm * 60 * 1000 + ss * 1000 + ff * 10\n    return ms\n  },\n  toTimeString: function (ms) {\n    var mm = Math.floor(ms / 1000 / 60)\n    var ss = Math.floor(ms / 1000 % 60)\n    var ff = Math.floor(ms % 1000)\n    var time = (mm < 10 ? '0' : '') + mm + ':' + (ss < 10 ? '0' : '') + ss + '.' + (ff < 100 ? '0' : '') + (ff < 10 ? '0' : Math.floor(ff / 10))\n    return time\n  }\n}\n\n/******************************************************************************************\n * Parses captions in LRC format: https://en.wikipedia.org/wiki/LRC_%28file_format%29\n ******************************************************************************************/\nfunction parse (content, options) {\n  var prev = null\n  var captions = [ ]\n  let caption\n  var parts = content.split(/\\r?\\n/)\n  for (var i = 0; i < parts.length; i++) {\n    if (!parts[i] || parts[i].trim().length === 0) {\n      continue\n    }\n\n    // LRC content\n    var regex = /^\\[(\\d{1,2}:\\d{1,2}([.,]\\d{1,3})?)\\](.*)(\\r?\\n)*$/gi\n    var match = regex.exec(parts[i])\n    if (match) {\n      caption = { }\n      caption.type = 'caption'\n      caption.start = helper.toMilliseconds(match[1])\n      caption.end = caption.start + 2000\n      caption.duration = caption.end - caption.start\n      caption.content = match[3]\n      caption.text = caption.content\n      captions.push(caption)\n\n      // Update previous\n      if (prev) {\n        prev.end = caption.start\n        prev.duration = prev.end - prev.start\n      }\n      prev = caption\n      continue\n    }\n\n    // LRC meta\n    var meta = /^\\[([\\w\\d]+):([^\\]]*)\\](\\r?\\n)*$/gi.exec(parts[i])\n    if (meta) {\n      caption = { }\n      caption.type = 'meta'\n      caption.tag = meta[1]\n      if (meta[2]) {\n        caption.data = meta[2]\n      }\n      captions.push(caption)\n      continue\n    }\n\n    if (options.verbose) {\n      console.log('WARN: Unknown part', parts[i])\n    }\n  }\n  return captions\n};\n\n/******************************************************************************************\n * Builds captions in LRC format: https://en.wikipedia.org/wiki/LRC_%28file_format%29\n ******************************************************************************************/\nfunction build (captions, options) {\n  var content = ''\n  var lyrics = false\n  var eol = options.eol || '\\r\\n'\n  for (var i = 0; i < captions.length; i++) {\n    var caption = captions[i]\n    if (caption.type === 'meta') {\n      if (caption.tag && caption.data) {\n        content += '[' + caption.tag + ':' + caption.data.replace(/[\\r\\n]+/g, ' ') + ']' + eol\n      }\n      continue\n    }\n\n    if (typeof caption.type === 'undefined' || caption.type === 'caption') {\n      if (!lyrics) {\n        content += eol // New line when lyrics start\n        lyrics = true\n      }\n      content += '[' + helper.toTimeString(caption.start) + ']' + caption.text + eol\n      continue\n    }\n\n    if (options.verbose) {\n      console.log('SKIP:', caption)\n    }\n  }\n\n  return content\n};\n\n/******************************************************************************************\n * Detects a subtitle format from the content.\n ******************************************************************************************/\nfunction detect (content) {\n  if (typeof content === 'string') {\n    if (/\\r?\\n\\[(\\d+:\\d{1,2}([.,]\\d{1,3})?)\\](.*)\\r?\\n/.test(content)) {\n      /*\n      [04:48.28]Sister, perfume?\n      */\n      // return \"lrc\";\n      return true\n    }\n  }\n};\n\n/******************************************************************************************\n * Export\n ******************************************************************************************/\nexport default {\n  name: FORMAT_NAME,\n  helper: helper,\n  detect: detect,\n  parse: parse,\n  build: build\n}\n","'use strict'\n\nvar FORMAT_NAME = 'smi'\n\nvar helper = {\n  htmlEncode: function (text) {\n    return text\n      .replace(/&/g, '&amp;')\n      .replace(/\"/g, '&quot;')\n      .replace(/'/g, '&#39;')\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;')\n      // .replace(/\\s/g, '&nbsp;')\n      .replace(/\\r?\\n/g, '<BR>')\n  },\n  htmlDecode: function (html, eol) {\n    return html\n      .replace(/<BR\\s*\\/?>/gi, eol || '\\r\\n')\n      .replace(/&nbsp;/g, ' ')\n      .replace(/&quot;/g, '\"')\n      .replace(/&#39;/g, \"'\")\n      .replace(/&lt;/g, '<')\n      .replace(/&gt;/g, '>')\n      .replace(/&amp;/g, '&')\n  }\n}\n\n/******************************************************************************************\n * Parses captions in SAMI format (.smi)\n ******************************************************************************************/\nfunction parse (content, options) {\n  var captions = [ ]\n  var eol = options.eol || '\\r\\n'\n  let caption\n  var title = /<TITLE[^>]*>([\\s\\S]*)<\\/TITLE>/gi.exec(content)\n  if (title) {\n    caption = { }\n    caption.type = 'meta'\n    caption.name = 'title'\n    caption.data = title[1].replace(/^[\\s\\r\\n]*/g, '').replace(/[\\s\\r\\n]*$/g, '')\n    captions.push(caption)\n  }\n\n  var style = /<STYLE[^>]*>([\\s\\S]*)<\\/STYLE>/gi.exec(content)\n  if (style) {\n    caption = { }\n    caption.type = 'meta'\n    caption.name = 'style'\n    caption.data = style[1]\n    captions.push(caption)\n  }\n\n  var sami = content\n    .replace(/^[\\s\\S]*<BODY[^>]*>/gi, '') // Remove content before body\n    .replace(/<\\/BODY[^>]*>[\\s\\S]*$/gi, '') // Remove content after body\n\n  var prev = null\n  var parts = sami.split(/<SYNC/gi)\n  for (var i = 0; i < parts.length; i++) {\n    if (!parts[i] || parts[i].trim().length === 0) {\n      continue\n    }\n\n    var part = '<SYNC' + parts[i]\n\n    // <SYNC Start = 1000>\n    var match = /^<SYNC[^>]+Start\\s*=\\s*[\"']?(\\d+)[\"']?[^>]*>([\\s\\S]*)/gi.exec(part)\n    if (match) {\n      caption = { }\n      caption.type = 'caption'\n      caption.start = parseInt(match[1])\n      caption.end = caption.start + 2000\n      caption.duration = caption.end - caption.start\n      caption.content = match[2].replace(/^<\\/SYNC[^>]*>/gi, '')\n\n      var blank = true\n      var p = /^<P[^>]+Class\\s*=\\s*[\"']?([\\w\\d\\-_]+)[\"']?[^>]*>([\\s\\S]*)/gi.exec(caption.content)\n      if (!p) {\n        p = /^<P([^>]*)>([\\s\\S]*)/gi.exec(caption.content)\n      }\n      if (p) {\n        var html = p[2].replace(/<P[\\s\\S]+$/gi, '') // Remove string after another <P> tag\n        html = html.replace(/<BR\\s*\\/?>/gi, eol).replace(/<[^>]+>/g, '') // Remove all tags\n        html = html.replace(/^[\\s\\r\\n]+/g, '').replace(/[\\s\\r\\n]+$/g, '') // Trim new lines and spaces\n        blank = (html.replace(/&nbsp;/gi, ' ').replace(/[\\s\\r\\n]+/g, '').length === 0)\n        caption.text = helper.htmlDecode(html, eol)\n      }\n\n      if (!options.preserveSpaces && blank) {\n        if (options.verbose) {\n          console.log('INFO: Skipping white space caption at ' + caption.start)\n        }\n      } else {\n        captions.push(caption)\n      }\n\n      // Update previous\n      if (prev) {\n        prev.end = caption.start\n        prev.duration = prev.end - prev.start\n      }\n      prev = caption\n      continue\n    }\n\n    if (options.verbose) {\n      console.log('WARN: Unknown part', parts[i])\n    }\n  }\n\n  return captions\n};\n\n/******************************************************************************************\n * Builds captions in SAMI format (.smi)\n ******************************************************************************************/\nfunction build (captions, options) {\n  var eol = options.eol || '\\r\\n'\n\n  var content = ''\n  content += '<SAMI>' + eol\n  content += '<HEAD>' + eol\n  content += '<TITLE>' + (options.title || '') + '</TITLE>' + eol\n  content += '<STYLE TYPE=\"text/css\">' + eol\n  content += '<!--' + eol\n  content += 'P { font-family: Arial; font-weight: normal; color: white; background-color: black; text-align: center; }' + eol\n  content += '.LANG { Name: ' + (options.langName || 'English') + '; lang: ' + (options.langCode || 'en-US') + '; SAMIType: CC; }' + eol\n  content += '-->' + eol\n  content += '</STYLE>' + eol\n  content += '</HEAD>' + eol\n  content += '<BODY>' + eol\n\n  for (var i = 0; i < captions.length; i++) {\n    var caption = captions[i]\n    if (caption.type === 'meta') {\n      continue\n    }\n\n    if (typeof caption.type === 'undefined' || caption.type === 'caption') {\n      // Start of caption\n      content += '<SYNC Start=' + caption.start + '>' + eol\n      content += '  <P Class=LANG>' + helper.htmlEncode(caption.text || '') + (options.closeTags ? '</P>' : '') + eol\n      if (options.closeTags) {\n        content += '</SYNC>' + eol\n      }\n\n      // Blank line indicates the end of caption\n      content += '<SYNC Start=' + caption.end + '>' + eol\n      content += '  <P Class=LANG>' + '&nbsp;' + (options.closeTags ? '</P>' : '') + eol\n      if (options.closeTags) {\n        content += '</SYNC>' + eol\n      }\n\n      continue\n    }\n\n    if (options.verbose) {\n      console.log('SKIP:', caption)\n    }\n  }\n\n  content += '</BODY>' + eol\n  content += '</SAMI>' + eol\n\n  return content\n};\n\n/******************************************************************************************\n * Detects a subtitle format from the content.\n ******************************************************************************************/\nfunction detect (content) {\n  if (typeof content === 'string') {\n    if (/<SAMI[^>]*>[\\s\\S]*<BODY[^>]*>/g.test(content)) {\n      /*\n      <SAMI>\n      <BODY>\n      <SYNC Start=...\n      ...\n      </BODY>\n      </SAMI>\n      */\n      return 'smi'\n    }\n  }\n};\n\n/******************************************************************************************\n * Export\n ******************************************************************************************/\nexport default {\n  name: FORMAT_NAME,\n  helper: helper,\n  detect: detect,\n  parse: parse,\n  build: build\n}\n","'use strict'\n\nvar FORMAT_NAME = 'ssa'\n\nvar helper = {\n  toMilliseconds: function (s) {\n    var match = /^\\s*(\\d+:)?(\\d{1,2}):(\\d{1,2})([.,](\\d{1,3}))?\\s*$/.exec(s)\n    var hh = match[1] ? parseInt(match[1].replace(':', '')) : 0\n    var mm = parseInt(match[2])\n    var ss = parseInt(match[3])\n    var ff = match[5] ? parseInt(match[5]) : 0\n    var ms = hh * 3600 * 1000 + mm * 60 * 1000 + ss * 1000 + ff * 10\n    return ms\n  },\n  toTimeString: function (ms) {\n    var hh = Math.floor(ms / 1000 / 3600)\n    var mm = Math.floor(ms / 1000 / 60 % 60)\n    var ss = Math.floor(ms / 1000 % 60)\n    var ff = Math.floor(ms % 1000 / 10) // 2 digits\n    var time = hh + ':' + (mm < 10 ? '0' : '') + mm + ':' + (ss < 10 ? '0' : '') + ss + '.' + (ff < 10 ? '0' : '') + ff\n    return time\n  }\n}\n\n/******************************************************************************************\n * Parses captions in SubStation Alpha format (.ssa)\n ******************************************************************************************/\n// Work-around for missing text (when the text contains ',' char)\nfunction getPosition (s, search, index) {\n  return s.split(search, index).join(search).length\n}\n\nfunction parse (content, options) {\n  var meta\n  var columns = null\n  var captions = [ ]\n\n  let caption\n  let values\n  let name\n  let value\n\n  var eol = options.eol || '\\r\\n'\n  var parts = content.split(/\\r?\\n\\s*\\r?\\n/)\n  for (var i = 0; i < parts.length; i++) {\n    var regex = /^\\s*\\[([^\\]]+)\\]\\r?\\n([\\s\\S]*)(\\r?\\n)*$/gi\n    var match = regex.exec(parts[i])\n    if (match) {\n      var tag = match[1]\n      var lines = match[2].split(/\\r?\\n/)\n      for (var l = 0; l < lines.length; l++) {\n        var line = lines[l]\n        if (/^\\s*;/.test(line)) {\n          continue // Skip comment\n        }\n        var m = /^\\s*([^:]+):\\s*(.*)(\\r?\\n)?$/.exec(line)\n        if (m) {\n          if (tag === 'Script Info') {\n            if (!meta) {\n              meta = { }\n              meta.type = 'meta'\n              meta.data = { }\n              captions.push(meta)\n            }\n            name = m[1].trim()\n            value = m[2].trim()\n            meta.data[name] = value\n            continue\n          }\n          if (tag === 'V4 Styles' || tag === 'V4+ Styles') {\n            name = m[1].trim()\n            value = m[2].trim()\n            if (name === 'Format') {\n              columns = value.split(/\\s*,\\s*/g)\n              continue\n            }\n            if (name === 'Style') {\n              values = value.split(/\\s*,\\s*/g)\n              caption = { }\n              caption.type = 'style'\n              caption.data = { }\n              for (var c = 0; c < columns.length && c < values.length; c++) {\n                caption.data[columns[c]] = values[c]\n              }\n              captions.push(caption)\n              continue\n            }\n          }\n          if (tag === 'Events') {\n            name = m[1].trim()\n            value = m[2].trim()\n            if (name === 'Format') {\n              columns = value.split(/\\s*,\\s*/g)\n              continue\n            }\n            if (name === 'Dialogue') {\n              values = value.split(/\\s*,\\s*/g)\n              caption = { }\n              caption.type = 'caption'\n              caption.data = { }\n              for (c = 0; c < columns.length && c < values.length; c++) {\n                caption.data[columns[c]] = values[c]\n              }\n              caption.start = helper.toMilliseconds(caption.data['Start'])\n              caption.end = helper.toMilliseconds(caption.data['End'])\n              caption.duration = caption.end - caption.start\n              caption.content = caption.data['Text']\n\n              var indexOfText = getPosition(value, ',', columns.length - 1) + 1\n              caption.content = value.substr(indexOfText)\n              caption.data['Text'] = caption.content\n\n              caption.text = caption.content\n                .replace(/\\\\N/g, eol) // \"\\N\" for new line\n                .replace(/\\{[^}]+\\}/g, '') // {\\pos(400,570)}\n              captions.push(caption)\n              continue\n            }\n          }\n        }\n      }\n    }\n\n    if (options.verbose) {\n      console.log('WARN: Unknown part', parts[i])\n    }\n  }\n  return captions\n};\n\n/******************************************************************************************\n * Builds captions in SubStation Alpha format (.ssa)\n ******************************************************************************************/\nfunction build (captions, options) {\n  var eol = options.eol || '\\r\\n'\n  var ass = options.format === 'ass'\n\n  var content = ''\n  content += '[Script Info]' + eol\n  content += '; Script generated by subsrt ' + eol\n  content += 'ScriptType: v4.00' + (ass ? '+' : '') + eol\n  content += 'Collisions: Normal' + eol\n  content += eol\n  if (ass) {\n    content += '[V4+ Styles]' + eol\n    content += 'Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding' + eol\n    content += 'Style: DefaultVCD, Arial,28,&H00B4FCFC,&H00B4FCFC,&H00000008,&H80000008,-1,0,0,0,100,100,0.00,0.00,1,1.00,2.00,2,30,30,30,0' + eol\n  } else {\n    content += '[V4 Styles]' + eol\n    content += 'Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, TertiaryColour, BackColour, Bold, Italic, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, AlphaLevel, Encoding' + eol\n    content += 'Style: DefaultVCD, Arial,28,11861244,11861244,11861244,-2147483640,-1,0,1,1,2,2,30,30,30,0,0' + eol\n  }\n  content += eol\n  content += '[Events]' + eol\n  content += 'Format: ' + (ass ? 'Layer' : 'Marked') + ', Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text' + eol\n\n  for (var i = 0; i < captions.length; i++) {\n    var caption = captions[i]\n    if (caption.type === 'meta') {\n      continue\n    }\n\n    if (typeof caption.type === 'undefined' || caption.type === 'caption') {\n      content += 'Dialogue: ' + (ass ? '0' : 'Marked=0') + ',' + helper.toTimeString(caption.start) + ',' + helper.toTimeString(caption.end) + ',DefaultVCD, NTP,0000,0000,0000,,' + caption.text.replace(/\\r?\\n/g, '\\\\N') + eol\n      continue\n    }\n\n    if (options.verbose) {\n      console.log('SKIP:', caption)\n    }\n  }\n\n  return content\n};\n\n/******************************************************************************************\n * Detects a subtitle format from the content.\n ******************************************************************************************/\nfunction detect (content) {\n  if (typeof content !== 'string') {\n    throw new Error('Expected string content!')\n  }\n\n  if (/^[\\s\\r\\n]*\\[Script Info\\]\\r?\\n/g.test(content) && /[\\s\\r\\n]*\\[Events\\]\\r?\\n/g.test(content)) {\n    /*\n    [Script Info]\n    ...\n    [Events]\n    */\n\n    // Advanced (V4+) styles for ASS format\n    return content.indexOf('[V4+ Styles]') > 0 ? 'ass' : 'ssa'\n  }\n};\n\n/******************************************************************************************\n * Export\n ******************************************************************************************/\nexport default {\n  name: FORMAT_NAME,\n  helper: helper,\n  detect: detect,\n  parse: parse,\n  build: build\n}\n","'use strict'\n\nimport ssa from './ssa'\n\nvar FORMAT_NAME = 'ass'\n\n// Compatible format\n\nexport default {\n  name: FORMAT_NAME,\n  helper: ssa.helper,\n  detect: ssa.detect,\n  parse: ssa.parse,\n  build: ssa.build\n}\n","'use strict'\n\nvar FORMAT_NAME = 'sub'\nvar DEFAULT_FPS = 25\n\n/******************************************************************************************\n * Parses captions in MicroDVD format: https://en.wikipedia.org/wiki/MicroDVD\n ******************************************************************************************/\nfunction parse (content, options) {\n  var fps = options.fps > 0 ? options.fps : DEFAULT_FPS\n  var captions = [ ]\n  var eol = options.eol || '\\r\\n'\n  var parts = content.split(/\\r?\\n/g)\n  for (var i = 0; i < parts.length; i++) {\n    var regex = /^\\{(\\d+)\\}\\{(\\d+)\\}(.*)$/gi\n    var match = regex.exec(parts[i])\n    if (match) {\n      var caption = { }\n      caption.type = 'caption'\n      caption.index = i + 1\n      caption.frame = {\n        start: parseInt(match[1]),\n        end: parseInt(match[2])\n      }\n      caption.frame.count = caption.frame.end - caption.frame.start\n      caption.start = Math.round(caption.frame.start / fps)\n      caption.end = Math.round(caption.frame.end / fps)\n      caption.duration = caption.end - caption.start\n      var lines = match[3].split(/\\|/g)\n      caption.content = lines.join(eol)\n      caption.text = caption.content.replace(/\\{[^}]+\\}/g, '') // {0}{25}{c:$0000ff}{y:b,u}{f:DeJaVuSans}{s:12}Hello!\n      captions.push(caption)\n      continue\n    }\n\n    if (options.verbose) {\n      console.log('WARN: Unknown part', parts[i])\n    }\n  }\n  return captions\n};\n\n/******************************************************************************************\n * Builds captions in MicroDVD format: https://en.wikipedia.org/wiki/MicroDVD\n ******************************************************************************************/\nfunction build (captions, options) {\n  var fps = options.fps > 0 ? options.fps : DEFAULT_FPS\n\n  var sub = ''\n  var eol = options.eol || '\\r\\n'\n  for (var i = 0; i < captions.length; i++) {\n    var caption = captions[i]\n    if (typeof caption.type === 'undefined' || caption.type === 'caption') {\n      var startFrame = typeof caption.frame === 'object' && caption.frame.start >= 0 ? caption.frame.start : caption.start * fps\n      var endFrame = typeof caption.frame === 'object' && caption.frame.end >= 0 ? caption.frame.end : caption.end * fps\n      var text = caption.text.replace(/\\r?\\n/, '|')\n      sub += '{' + startFrame + '}' + '{' + endFrame + '}' + text + eol\n      continue\n    }\n\n    if (options.verbose) {\n      console.log('SKIP:', caption)\n    }\n  }\n\n  return sub\n};\n\n/******************************************************************************************\n * Detects a subtitle format from the content.\n ******************************************************************************************/\nfunction detect (content) {\n  if (typeof content === 'string') {\n    if (/^\\{\\d+\\}\\{\\d+\\}(.*)/.test(content)) {\n      /*\n      {7207}{7262}Sister, perfume?\n      */\n      return FORMAT_NAME\n    }\n  }\n};\n\n/******************************************************************************************\n * Export\n ******************************************************************************************/\nexport default {\n  name: FORMAT_NAME,\n  detect: detect,\n  parse: parse,\n  build: build\n}\n","'use strict'\n\nvar FORMAT_NAME = 'srt'\n\nvar helper = {\n  toMilliseconds: function (s) {\n    var match = /^\\s*(\\d{1,2}):(\\d{1,2}):(\\d{1,2})([.,](\\d{1,3}))?\\s*$/.exec(s)\n    var hh = parseInt(match[1])\n    var mm = parseInt(match[2])\n    var ss = parseInt(match[3])\n    var ff = match[5] ? parseInt(match[5]) : 0\n    var ms = hh * 3600 * 1000 + mm * 60 * 1000 + ss * 1000 + ff\n    return ms\n  },\n  toTimeString: function (ms) {\n    var hh = Math.floor(ms / 1000 / 3600)\n    var mm = Math.floor(ms / 1000 / 60 % 60)\n    var ss = Math.floor(ms / 1000 % 60)\n    var ff = Math.floor(ms % 1000)\n    var time = (hh < 10 ? '0' : '') + hh + ':' + (mm < 10 ? '0' : '') + mm + ':' + (ss < 10 ? '0' : '') + ss + ',' + (ff < 100 ? '0' : '') + (ff < 10 ? '0' : '') + ff\n    return time\n  }\n}\n\n/******************************************************************************************\n * Parses captions in SubRip format (.srt)\n ******************************************************************************************/\nfunction parse (content, options) {\n  var captions = [ ]\n  var eol = options.eol || '\\r\\n'\n  var parts = content.split(/\\r?\\n\\s+\\r?\\n/g)\n  for (var i = 0; i < parts.length; i++) {\n    var regex = /^(\\d+)\\r?\\n(\\d{1,2}:\\d{1,2}:\\d{1,2}([.,]\\d{1,3})?)\\s*-->\\s*(\\d{1,2}:\\d{1,2}:\\d{1,2}([.,]\\d{1,3})?)\\r?\\n([\\s\\S]*)(\\r?\\n)*$/gi\n    var match = regex.exec(parts[i])\n    if (match) {\n      var caption = { }\n      caption.type = 'caption'\n      caption.index = parseInt(match[1])\n      caption.start = helper.toMilliseconds(match[2])\n      caption.end = helper.toMilliseconds(match[4])\n      caption.duration = caption.end - caption.start\n      var lines = match[6].split(/\\r?\\n/)\n      caption.content = lines.join(eol)\n      caption.text = caption.content\n        .replace(/<[^>]+>/g, '') // <b>bold</b> or <i>italic</i>\n        .replace(/\\{[^}]+\\}/g, '') // {b}bold{/b} or {i}italic{/i}\n        .replace(/>>\\s*[^:]*:\\s*/g, '') // >> SPEAKER NAME:\n      captions.push(caption)\n      continue\n    }\n\n    if (options.verbose) {\n      console.log('WARN: Unknown part', parts[i])\n    }\n  }\n  return captions\n};\n\n/******************************************************************************************\n * Builds captions in SubRip format (.srt)\n ******************************************************************************************/\nfunction build (captions, options) {\n  var srt = ''\n  var eol = options.eol || '\\r\\n'\n  for (var i = 0; i < captions.length; i++) {\n    var caption = captions[i]\n    if (typeof caption.type === 'undefined' || caption.type === 'caption') {\n      srt += (i + 1).toString() + eol\n      srt += helper.toTimeString(caption.start) + ' --> ' + helper.toTimeString(caption.end) + eol\n      srt += caption.text + eol\n      srt += eol\n      continue\n    }\n    if (options.verbose) {\n      console.log('SKIP:', caption)\n    }\n  }\n\n  return srt\n};\n\n/******************************************************************************************\n * Detects a subtitle format from the content.\n ******************************************************************************************/\nfunction detect (content) {\n  if (typeof content === 'string') {\n    if (/\\d+\\r?\\n\\d{1,2}:\\d{1,2}:\\d{1,2}([.,]\\d{1,3})?\\s*-->\\s*\\d{1,2}:\\d{1,2}:\\d{1,2}([.,]\\d{1,3})?/g.test(content)) {\n      /*\n      3\n      00:04:48,280 --> 00:04:50,510\n      Sister, perfume?\n      */\n      return FORMAT_NAME\n    }\n  }\n};\n\n/******************************************************************************************\n * Export\n ******************************************************************************************/\nexport default {\n  name: FORMAT_NAME,\n  helper: helper,\n  detect: detect,\n  parse: parse,\n  build: build\n}\n","'use strict'\n\nvar FORMAT_NAME = 'sbv'\n\nvar helper = {\n  toMilliseconds: function (s) {\n    var match = /^\\s*(\\d{1,2}):(\\d{1,2}):(\\d{1,2})([.,](\\d{1,3}))?\\s*$/.exec(s)\n    var hh = parseInt(match[1])\n    var mm = parseInt(match[2])\n    var ss = parseInt(match[3])\n    var ff = match[5] ? parseInt(match[5]) : 0\n    var ms = hh * 3600 * 1000 + mm * 60 * 1000 + ss * 1000 + ff\n    return ms\n  },\n  toTimeString: function (ms) {\n    var hh = Math.floor(ms / 1000 / 3600)\n    var mm = Math.floor(ms / 1000 / 60 % 60)\n    var ss = Math.floor(ms / 1000 % 60)\n    var ff = Math.floor(ms % 1000)\n    var time = (hh < 10 ? '0' : '') + hh + ':' + (mm < 10 ? '0' : '') + mm + ':' + (ss < 10 ? '0' : '') + ss + '.' + (ff < 100 ? '0' : '') + (ff < 10 ? '0' : '') + ff\n    return time\n  }\n}\n\n/******************************************************************************************\n * Parses captions in SubViewer format (.sbv)\n ******************************************************************************************/\nfunction parse (content, options) {\n  var captions = [ ]\n  var eol = options.eol || '\\r\\n'\n  var parts = content.split(/\\r?\\n\\s+\\r?\\n/)\n  for (var i = 0; i < parts.length; i++) {\n    var regex = /^(\\d{1,2}:\\d{1,2}:\\d{1,2}([.,]\\d{1,3})?)\\s*[,;]\\s*(\\d{1,2}:\\d{1,2}:\\d{1,2}([.,]\\d{1,3})?)\\r?\\n([\\s\\S]*)(\\r?\\n)*$/gi\n    var match = regex.exec(parts[i])\n    if (match) {\n      var caption = { }\n      caption.type = 'caption'\n      caption.start = helper.toMilliseconds(match[1])\n      caption.end = helper.toMilliseconds(match[3])\n      caption.duration = caption.end - caption.start\n      var lines = match[5].split(/\\[br\\]|\\r?\\n/gi)\n      caption.content = lines.join(eol)\n      caption.text = caption.content.replace(/>>\\s*[^:]+:\\s*/g, '') // >> SPEAKER NAME:\n      captions.push(caption)\n      continue\n    }\n\n    if (options.verbose) {\n      console.log('WARN: Unknown part', parts[i])\n    }\n  }\n  return captions\n};\n\n/******************************************************************************************\n * Builds captions in SubViewer format (.sbv)\n ******************************************************************************************/\nfunction build (captions, options) {\n  var content = ''\n  var eol = options.eol || '\\r\\n'\n  for (var i = 0; i < captions.length; i++) {\n    var caption = captions[i]\n    if (typeof caption.type === 'undefined' || caption.type === 'caption') {\n      content += helper.toTimeString(caption.start) + ',' + helper.toTimeString(caption.end) + eol\n      content += caption.text + eol\n      content += eol\n      continue\n    }\n    if (options.verbose) {\n      console.log('SKIP:', caption)\n    }\n  }\n\n  return content\n};\n\n/******************************************************************************************\n * Detects a subtitle format from the content.\n ******************************************************************************************/\nfunction detect (content) {\n  if (typeof content !== 'string') {\n    throw new Error('Expected string content!')\n  }\n\n  if (/\\d{1,2}:\\d{1,2}:\\d{1,2}([.,]\\d{1,3})?\\s*[,;]\\s*\\d{1,2}:\\d{1,2}:\\d{1,2}([.,]\\d{1,3})?/g.test(content)) {\n    /*\n    00:04:48.280,00:04:50.510\n    Sister, perfume?\n    */\n    return 'sbv'\n  }\n};\n\n/******************************************************************************************\n * Export\n ******************************************************************************************/\nexport default {\n  name: FORMAT_NAME,\n  helper: helper,\n  detect: detect,\n  parse: parse,\n  build: build\n}\n","'use strict'\n\nvar FORMAT_NAME = 'json'\n\n/******************************************************************************************\n * Parses captions in JSON format\n ******************************************************************************************/\nfunction parse (content, options) {\n  return JSON.parse(content)\n};\n\n/******************************************************************************************\n * Builds captions in JSON format\n ******************************************************************************************/\nfunction build (captions, options) {\n  return JSON.stringify(captions, ' ', 2)\n}\n\n/******************************************************************************************\n * Detects a subtitle format from the content.\n ******************************************************************************************/\nfunction detect (content) {\n  if (typeof content === 'string') {\n    if (/^\\[[\\s\\r\\n]*\\{[\\s\\S]*\\}[\\s\\r\\n]*\\]$/g.test(content)) {\n      /*\n      [\n        { ... }\n      ]\n      */\n      return 'json'\n    }\n  }\n};\n\n/******************************************************************************************\n * Export\n ******************************************************************************************/\nexport default {\n  name: FORMAT_NAME,\n  detect: detect,\n  parse: parse,\n  build: build\n}\n","'use strict'\n\nimport vttHandler from './format/vtt.js'\nimport lrcHandler from './format/lrc.js'\nimport smiHandler from './format/smi.js'\nimport ssaHandler from './format/ssa.js'\nimport assHandler from './format/ass.js'\nimport subHandler from './format/sub.js'\nimport srtHandler from './format/srt.js'\nimport sbvHandler from './format/sbv.js'\nimport jsonHandler from './format/json.js'\n\nvar subsrt = {\n  format: { }\n}\n\nfunction clone (obj) {\n  return JSON.parse(JSON.stringify(obj))\n}\n\n/******************************************************************************************\n * Loads the subtitle format parsers and builders\n ******************************************************************************************/\n(function init () {\n  // Load in the predefined order\n  const handlers = [\n    vttHandler,\n    lrcHandler,\n    smiHandler,\n    ssaHandler,\n    assHandler,\n    subHandler,\n    srtHandler,\n    sbvHandler,\n    jsonHandler\n  ]\n  for (var i = 0; i < handlers.length; i++) {\n    var handler = handlers[i]\n    subsrt.format[handler.name] = handler\n  }\n})()\n\n/******************************************************************************************\n * Gets a list of supported subtitle formats.\n ******************************************************************************************/\nsubsrt.list = function () {\n  return Object.keys(subsrt.format)\n}\n\n/******************************************************************************************\n * Detects a subtitle format from the content.\n ******************************************************************************************/\nsubsrt.detect = function (content) {\n  var formats = subsrt.list()\n  for (var i = 0; i < formats.length; i++) {\n    var f = formats[i]\n    var handler = subsrt.format[f]\n    if (typeof handler === 'undefined') {\n      continue\n    }\n    if (typeof handler.detect !== 'function') {\n      continue\n    }\n    // Function 'detect' can return true or format name\n    var d = handler.detect(content)\n    if (d === true) { // Logical true\n      return f\n    }\n    if (f === d) { // Format name\n      return d\n    }\n  }\n}\n\n/******************************************************************************************\n * Parses a subtitle content.\n ******************************************************************************************/\nsubsrt.parse = function (content, options) {\n  options = options || { }\n  var format = options.format || subsrt.detect(content)\n  if (!format || format.trim().length === 0) {\n    throw new Error('Cannot determine subtitle format!')\n  }\n\n  var handler = subsrt.format[format]\n  if (typeof handler === 'undefined') {\n    throw new Error('Unsupported subtitle format: ' + format)\n  }\n\n  var func = handler.parse\n  if (typeof func !== 'function') {\n    throw new Error(\"Subtitle format does not support 'parse' op: \" + format)\n  }\n\n  return func(content, options)\n}\n\n/******************************************************************************************\n * Builds a subtitle content\n ******************************************************************************************/\nsubsrt.build = function (captions, options) {\n  options = options || { }\n  var format = options.format || 'srt'\n  if (!format || format.trim().length === 0) {\n    throw new Error('Cannot determine subtitle format!')\n  }\n\n  var handler = subsrt.format[format]\n  if (typeof handler === 'undefined') {\n    throw new Error('Unsupported subtitle format: ' + format)\n  }\n\n  var func = handler.build\n  if (typeof func !== 'function') {\n    throw new Error(\"Subtitle format does not support 'build' op: \" + format)\n  }\n\n  return func(captions, options)\n}\n\n/******************************************************************************************\n * Converts subtitle format\n ******************************************************************************************/\nsubsrt.convert = function (content, options) {\n  if (typeof options === 'string') {\n    options = { to: options }\n  }\n  options = options || { }\n\n  var opt = clone(options)\n  delete opt.format\n\n  if (opt.from) {\n    opt.format = opt.from\n  }\n\n  var captions = subsrt.parse(content, opt)\n  if (opt.resync) {\n    captions = subsrt.resync(captions, opt.resync)\n  }\n\n  opt.format = opt.to || options.format\n  var result = subsrt.build(captions, opt)\n\n  return result\n}\n\n/******************************************************************************************\n * Shifts the time of the captions.\n ******************************************************************************************/\nsubsrt.resync = function (captions, options) {\n  options = options || { }\n  let shift\n  var func, ratio, frame, offset\n  if (typeof options === 'function') {\n    func = options // User's function to handle time shift\n  } else if (typeof options === 'number') {\n    offset = options // Time shift (+/- offset)\n    func = function (a) {\n      return [ a[0] + offset, a[1] + offset ]\n    }\n  } else if (typeof options === 'object') {\n    offset = (options.offset || 0) * (options.frame ? options.fps || 25 : 1)\n    ratio = options.ratio || 1.0\n    frame = options.frame\n    func = function (a) {\n      return [ Math.round(a[0] * ratio + offset), Math.round(a[1] * ratio + offset) ]\n    }\n  } else {\n    throw new Error(\"Argument 'options' not defined!\")\n  }\n\n  var resynced = [ ]\n  for (var i = 0; i < captions.length; i++) {\n    var caption = clone(captions[i])\n    if (typeof caption.type === 'undefined' || caption.type === 'caption') {\n      if (frame) {\n        shift = func([ caption.frame.start, caption.frame.end ])\n        if (shift && shift.length === 2) {\n          caption.frame.start = shift[0]\n          caption.frame.end = shift[1]\n          caption.frame.count = caption.frame.end - caption.frame.start\n        }\n      } else {\n        shift = func([ caption.start, caption.end ])\n        if (shift && shift.length === 2) {\n          caption.start = shift[0]\n          caption.end = shift[1]\n          caption.duration = caption.end - caption.start\n        }\n      }\n    }\n    resynced.push(caption)\n  }\n\n  return resynced\n}\n\nexport default subsrt\n"],"sourceRoot":""}